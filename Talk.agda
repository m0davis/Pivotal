{----------------------------------------------------------------------------







                 How to Keep Your Neighbours in Order


                            Conor McBride




  locally            Microsoft Research Cambridge
  usually             University of Strathclyde









                                                                    -- next, message


----------------------------------------------------------------------------}


{----------------------------------------------------------------------------

 25 minutes is a short slot, so best get straight to the message...




























----------------------------------------------------------------------------}

{----------------------------------------------------------------------------

 25 minutes is a short slot, so best get straight to the message...


                             $$$$$ $   $ $$$$  $$$$$  $$$$
                               $    $ $  $   $ $     $
                               $     $   $$$$  $$$$   $$$ 
                               $     $   $     $         $
                               $     $   $     $$$$$ $$$$  
     




















----------------------------------------------------------------------------}

{----------------------------------------------------------------------------

 25 minutes is a short slot, so best get straight to the message...


  $$$$  $   $  $$$$ $   $    $$$$$ $   $ $$$$  $$$$$  $$$$
  $   $ $   $ $     $   $      $    $ $  $   $ $     $
  $$$$  $   $  $$$  $$$$$      $     $   $$$$  $$$$   $$$
  $     $   $     $ $   $      $     $   $     $         $
  $      $$$  $$$$  $   $      $     $   $     $$$$$ $$$$
     






















----------------------------------------------------------------------------}

{----------------------------------------------------------------------------

 25 minutes is a short slot, so best get straight to the message...


  $$$$  $   $  $$$$ $   $    $$$$$ $   $ $$$$  $$$$$  $$$$    $ $   $
  $   $ $   $ $     $   $      $    $ $  $   $ $     $        $ $$  $
  $$$$  $   $  $$$  $$$$$      $     $   $$$$  $$$$   $$$     $ $ $ $
  $     $   $     $ $   $      $     $   $     $         $    $ $  $$
  $      $$$  $$$$  $   $      $     $   $     $$$$$ $$$$     $ $   $
     




















----------------------------------------------------------------------------}

{----------------------------------------------------------------------------

 25 minutes is a short slot, so best get straight to the message...


  $$$$  $   $  $$$$ $   $    $$$$$ $   $ $$$$  $$$$$  $$$$    $ $   $
  $   $ $   $ $     $   $      $    $ $  $   $ $     $        $ $$  $
  $$$$  $   $  $$$  $$$$$      $     $   $$$$  $$$$   $$$     $ $ $ $
  $     $   $     $ $   $      $     $   $     $         $    $ $  $$
  $      $$$  $$$$  $   $      $     $   $     $$$$$ $$$$     $ $   $
     

$$$$$ $   $ $$$$  $$$$$ $     $$$$$  $$$$  $$$$     $$$$  $$$  $$$$  $$$$$
  $    $ $  $   $ $     $     $     $     $        $     $   $ $   $ $
  $     $   $$$$  $$$$  $     $$$$   $$$   $$$     $     $   $ $   $ $$$$
  $     $   $     $     $     $         $     $    $     $   $ $   $ $
  $     $   $     $$$$$ $$$$$ $$$$$ $$$$  $$$$      $$$$  $$$  $$$$  $$$$$














----------------------------------------------------------------------------}

{----------------------------------------------------------------------------

 25 minutes is a short slot, so best get straight to the message...


  $$$$  $   $  $$$$ $   $    $$$$$ $   $ $$$$  $$$$$  $$$$    $ $   $
  $   $ $   $ $     $   $      $    $ $  $   $ $     $        $ $$  $
  $$$$  $   $  $$$  $$$$$      $     $   $$$$  $$$$   $$$     $ $ $ $
  $     $   $     $ $   $      $     $   $     $         $    $ $  $$
  $      $$$  $$$$  $   $      $     $   $     $$$$$ $$$$     $ $   $
     

$$$$$ $   $ $$$$  $$$$$    $     $$$$$  $$$$  $$$$     $$$$  $$$  $$$$  $$$$$
  $    $ $  $   $ $        $     $     $     $        $     $   $ $   $ $    
  $     $   $$$$  $$$$     $     $$$$   $$$   $$$     $     $   $ $   $ $$$$ 
  $     $   $     $        $     $         $     $    $     $   $ $   $ $    
  $     $   $     $$$$$    $$$$$ $$$$$ $$$$  $$$$      $$$$  $$$  $$$$  $$$$$













----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

 25 minutes is a short slot, so best get straight to the message...


  $$$$  $   $  $$$$ $   $    $$$$$ $   $ $$$$  $$$$$  $$$$    $ $   $
  $   $ $   $ $     $   $      $    $ $  $   $ $     $        $ $$  $
  $$$$  $   $  $$$  $$$$$      $     $   $$$$  $$$$   $$$     $ $ $ $
  $     $   $     $ $   $      $     $   $     $         $    $ $  $$
  $      $$$  $$$$  $   $      $     $   $     $$$$$ $$$$     $ $   $
     

$$$$$ $   $ $$$$  $$$$$    $     $$$$$  $$$$  $$$$     $$$$  $$$  $$$$  $$$$$
  $    $ $  $   $ $        $     $     $     $        $     $   $ $   $ $    
  $     $   $$$$  $$$$     $     $$$$   $$$   $$$     $     $   $ $   $ $$$$ 
  $     $   $     $        $     $         $     $    $     $   $ $   $ $    
  $     $   $     $$$$$    $$$$$ $$$$$ $$$$  $$$$      $$$$  $$$  $$$$  $$$$$


  $$$$  $$$$   $$$  $   $ $$$$$    $   $  $$$  $$$$$ $   $ $ $   $  $$$$
  $   $ $   $ $   $ $   $ $        $$  $ $   $   $   $   $ $ $$  $ $  
  $$$$  $$$$  $   $  $ $  $$$$     $ $ $ $   $   $   $$$$$ $ $ $ $ $  $$
  $     $   $ $   $  $ $  $        $  $$ $   $   $   $   $ $ $  $$ $   $
  $     $   $  $$$    $   $$$$$    $   $  $$$    $   $   $ $ $   $  $$$







----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ...........6...
                           :               :
                        ...3.......       .8...
                       :           :     :     :
                    ...2.       ...5.    -    .9.
                   :     :     :     :       :   :
                  .1.    -    .4.    -       -   -
                 :   :       :   :
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :           6   :
                        ...3.......       .8...
                       :           :     :     :
                    ...2.       ...5.    -    .9.
                   :     :     :     :       :   :
                  .1.    -    .4.    -       -   -
                 :   :       :   :
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ...3.......    6  .8...
                       :           :     :     :
                    ...2.       ...5.    -    .9.
                   :     :     :     :       :   :
                  .1.    -    .4.    -       -   -
                 :   :       :   :
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :   3       :   6 : 8   :
                    ...2.       ...5.    -    .9.
                   :     :     :     :       :   :
                  .1.    -    .4.    -       -   -
                 :   :       :   :
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ...2.  3    ...5.  6 - 8  .9.
                   :     :     :     :       :   :
                  .1.    -    .4.    -       -   -
                 :   :       :   :
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :   2 : 3   :   5 : 6 - 8 : 9 :
                  .1.    -    .4.    -       -   -
                 :   :       :   :
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  .1.  2 - 3  .4.  5 - 6 - 8 - 9 -
                 :   :       :   :
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 : 1 : 2 - 3 : 4 : 5 - 6 - 8 - 9 -
                 -   -       -   -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :
                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -
















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :

                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -















----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :


                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -














----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :



                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -













----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :




                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -












----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :





                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -











----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :






                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -










----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :





                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -











----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :






                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -


(stop pressing the button, Conor)







----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :






                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -


(really stop pressing the button, Conor)







----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree


                            ........... ...
                           :               :
                        ... .......       . ...
                       :           :     :     :
                    ... .       ... .         . .
                   :     :     :     :       :   :
                  . .         . .
                 :   :       :   :






                 - 1 - 2 - 3 - 4 - 5 - 6 - 8 - 9 -


(really really stop pressing the button, Conor)







----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree

              bot                                 top
               |            ...........6...        | 
               |           :               :       | 
               |        ...3.......       .8...    | 
               |       :           :     :     :   | 
               |    ...2.       ...5.    -    .9.  | 
               |   :     :     :     :       :   : | 
               |  .1.    -    .4.    -       -   - | 
               | :   :       :   :                 | 
               | -   -       -   -                 | 
               |                                   | 

  Think about requirements













----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree

              bot                                 top
               |            ...........6...        | 
               |           :           |   :       | 
               |        ...3.......    |  .8...    | 
               |       :           :   | :     :   | 
               |    ...2.       ...5.  | -    .9.  | 
               |   :     :     :     : |     :   : | 
               |  .1.    -    .4.    - |     -   - | 
               | :   :       :   :     |           | 
               | -   -       -   -     |           | 
               |                       |           | 

  Think about requirements













----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree

              bot                                 top
               |            ...........6...        | 
               |           :           |   :       | 
               |        ...3.......    |  .8...    | 
               |       :   |       :   | : |   :   | 
               |    ...2.  |    ...5.  | - |  .9.  | 
               |   :     : |   :     : |   | :   : | 
               |  .1.    - |  .4.    - |   | -   - | 
               | :   :     | :   :     |   |       | 
               | -   -     | -   -     |   |       | 
               |           |           |   |       | 

  Think about requirements













----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree

              bot                                 top
               |            ...........6...        | 
               |           :           |   :       | 
               |        ...3.......    |  .8...    | 
               |       :   |       :   | : |   :   | 
               |    ...2.  |    ...5.  | - |  .9.  | 
               |   :   | : |   :   | : |   | : | : | 
               |  .1.  | - |  .4.  | - |   | - | - | 
               | :   : |   | :   : |   |   |   |   | 
               | -   - |   | -   - |   |   |   |   | 
               |       |   |       |   |   |   |   | 

  Think about requirements













----------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Consider the binary search tree

              bot                                 top
               |            ...........6...        | 
               |           :           |   :       | 
               |        ...3.......    |  .8...    | 
               |       :   |       :   | : |   :   | 
               |    ...2.  |    ...5.  | - |  .9.  | 
               |   :   | : |   :   | : |   | : | : | 
               |  .1.  | - |  .4.  | - |   | - | - | 
               | : | : |   | : | : |   |   |   |   | 
               | - | - |   | - | - |   |   |   |   | 
               |   |   |   |   |   |   |   |   |   | 

  Think about requirements

  Values at nodes make it easy to push sufficient requirements inward

  We could bubble observations of extrema outward, but... 

  ...pain.





                                                                      -- next, Prf

----------------------------------------------------------------------------}

module Talk where

data Zero : Set where

record One : Set where constructor <>

data _+_ (S T : Set) : Set where
  inl : S -> S + T
  inr : T -> S + T

record Sg (S : Set)(T : S -> Set) : Set where
  constructor _,_
  field
    fst : S
    snd : T fst
open Sg
_*_ : Set -> Set -> Set
S * T = Sg S \ _ -> T
infixr 4 _,_ _*_

data Nat : Set where
  ze : Nat
  su : Nat -> Nat

{-# BUILTIN NATURAL Nat #-}


Pred : Set -> Set1
Pred S = S -> Set

Zero- One- : forall {S} -> Pred S
Zero- s = Zero
One- s = One

_+-_ _*-_ _->-_ : forall {S} -> Pred S -> Pred S -> Pred S
(P +- Q) s   = P s + Q s
(P *- Q) s   = P s * Q s
(P ->- Q) s  = P s -> Q s
infixr 3 _+-_
infixr 4 _*-_
infixr 2 _->-_

[-_-] : forall {S} -> Pred S -> Set
[- P -] = forall {s} -> P s

Rel : Set -> Set1
Rel X = Pred (X * X)





{----------------------------------------------------------------------------}

{- How to hide the truth -}

   -- introduce a wrapper type for "boring" proof sets

record Prf (T : Set) : Set where
  constructor !
  field
    {{prf}} : T      -- this field is {{implicit}}
open Prf

{-(-}
tryThis : {A B : Set} -> Prf A -> Prf B -> Prf A
tryThis ! ! = !
{-)-}

  -- McBride's guide to Agda implicits

  -- absent brace - full explanation
  -- single brace - by type equation
  -- double brace - just observation
  -- I will bet a claret case that we'll invent the triple brace





                                                                    -- next, OWOTO


{----------------------------------------------------------------------------}

  -- The key property of our ordering relation is
  -- just that any two values can be put in order,  O.ne W.ay O.r T.he O.ther

OWOTO : forall {P} -> Rel P -> Rel P
OWOTO L (x , y) = Prf (L (x , y)) + Prf (L (y , x))

pattern le = inl !
pattern ge = inr !

  -- Because ! is a *constructor*, I can use it in a *pattern synonym*.

  -- le and ge to construct and match on ordering info, keeping proofs silent

  -- cheatsheet:
  --                Pred X = X -> Set
  --                Rel P = Pred (P * P)

  -- parametrize the development by an element type with a suitable ordering.

module Order   {P : Set}(L : Rel P)  (owoto : (x y : P) -> OWOTO L (x , y))
  where





                                                                       -- next, Bnd

{----------------------------------------------------------------------------}

  -- Our element type may not have have extremal elements.

  -- To get a type we can use for *bounds* on trees, let's add bot and top.

  data Bnd : Set where
    bot : Bnd
    val : P -> Bnd
    top : Bnd

  -- We can readily extend our ordering to bot and top.

  LH LB : Rel Bnd
  LH (bot    , _     ) = One
  LH (val x  , val y ) = L (x , y)
  LH (_      , top   ) = One
  LH         _         = Zero
  LB xy = Prf (LH xy)

  -- LH does the work.
  -- LB hides it.






                                                                 -- next, bifunctors

{----------------------------------------------------------------------------}

  -- By a curious coincidence, I'm sitting next to Patrik Jansson as I write
  -- this slide about a universe of bifunctors, just like the one in PolyP.

  data U : Set where
    `R `P : U                        -- R for RECURSIVE place, P for PARAMETER
    `0 `1 : U                        -- empty type, unit type
    _`+_ _`*_ : (S T : U) -> U       -- sums and products

  -- we interpret U-values as functors in the R to go recursive positions

  UF : U -> Set -> Set
  UF `R       R  =  R
  UF `P       R  =  P
  UF `0       R  =  Zero
  UF `1       R  =  One
  UF (S `+ T) R  =  UF S R + UF T R
  UF (S `* T) R  =  UF S R * UF T R

  -- now, tie the recursive knot

  data MuU (T : U) : Set where
    <_> : UF T (MuU T) -> MuU T




                                                               -- next P with * is ^

{----------------------------------------------------------------------------}

  -- to build data structures which are easy to order, combine `P with `*

  _^-_ : Rel Bnd -> Rel Bnd -> Rel Bnd
  (S ^- T) (l , u) = Sg P \ p -> S (l , val p) * T (val p , u)




  -- If S and T are bounded structures, S ^- T is the bounded structure like
  --
  --                l         u
  --                |  ..p..  |
  --                | :  |  : |
  --                | s  |  t |
  --                |    |    |



  pattern _/_/_ lp p pu = p , lp , pu      -- cosmetic surgery







                                                                     -- next, OU

{----------------------------------------------------------------------------}

  -- the simple Orderable Universe (of boundable bifunctors)

  -- the codes

  data OU : Set where
    `R        : OU
    `0 `1     : OU
    _`+_ _`^_ : (S T : OU) -> OU

  -- their meaning

  OUF : OU -> Rel Bnd -> Rel Bnd
  OUF `R       R = R
  OUF `0       R = Zero-
  OUF `1       R = LB                  -- ordering evidence at the leaves
  OUF (S `+ T) R = OUF S R +- OUF T R
  OUF (S `^ T) R = OUF S R ^- OUF T R  -- nodes which look like  s / p / t

  -- typing the recursive knot

  data MuOU (T : OU)(lu : Bnd * Bnd) : Set where  -- MuOU T : Rel Bnd
    <_> : OUF T (MuOU T) lu -> MuOU T lu




                                                                  -- next, examples!

-- banana section
{----------------------------------------------------------------------------}

  -- Some of our favourite structures

  Intv : Rel Bnd
  Intv = MuOU (`1 `^ `1)
  pattern [_] p = < ! / p / ! >

  -- for an example, C-s mango

  Tree : Rel Bnd
  Tree = MuOU (`1 `+ (`R `^ `R))
  pattern leaf          =  < inl ! >
  pattern node lp p pu  =  < inr (lp / p / pu) >

  List = MuOU (`1 `+ (`1 `^ `R))
  pattern nil        =  < inl ! >
  pattern _::_ x xs  =  < inr (! / x / xs) >

  -- a list is a right-spiny tree








                                                                 -- next, insert

{----------------------------------------------------------------------------}

-- Our operations are index-respecting, so lift everything pointwise.

--   [-_-] : forall {S} -> Pred S -> Set
--   [- P -] = forall {s} -> P s

{-(-}
  insert : [- Intv ->- Tree ->- Tree -]
  insert [ x ] leaf = node leaf x leaf
  insert [ x ] (node lp p pu) with owoto x p
  ... | le = node (insert [ x ] lp) p pu
  ... | ge = node lp p (insert [ x ] pu)
{-)-}
{-(-}
  cat : [- List ^- List ->- List -]
  cat (nil / p / ys)        = p :: ys
  cat ((x :: xs) / p / ys)  = x :: cat (xs / p / ys)
{-)-}
{-(-}
  flat : [- Tree ->- List -]
  flat leaf            = nil
  flat (node lp p pu)  = cat (flat lp / p / flat pu)
{-)-}







                                                                 -- next, flattening

{----------------------------------------------------------------------------

  Defeat snatched from jaws of victory: quadratic flattening

 
























---------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Defeat snatched from jaws of victory: quadratic flattening

    WORKER/WRAPPER/MAKES IT/FASTER

    introduce an accumulator






















---------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Defeat snatched from jaws of victory: quadratic flattening

    WORKER/WRAPPER/MAKES IT/FASTER

    introduce an accumulator, but what are its bounds?






















---------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Victory snatched from jaws of victory: linear flattening?

  l                     u
      .......3...                       tree in
     :           :
    .1...       .4...
   :     :     :     :
   -    .2.    -    .5.
       :   :       :   :
       -   -       -   -

                      ?????????????            accumulator?

  













---------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Victory snatched from jaws of victory: linear flattening?

  l                     u
      .......3...                       tree in
     :           :
    .1...       .4...
   :     :     :     :
   -    .2.    -    .5.
       :   :       :   :
       -   -       -   ?                replace the last leaf

                      ?????????????     by the accumulator

  













---------------------------------------------------------------------------}
{----------------------------------------------------------------------------

  Victory snatched from jaws of victory: linear flattening?

  l                     u
      .......3...                       tree in
     :           :
    .1...       .4...
   :     :     :     :
   -    .2.    -    .5.
       :   :       :   :
       -   -       -  y-u
                      |  \
     
                      |     \

                      |        \

                      |           \
                       - 6 - 7 - 8 -    list in  *any*where left of u
  l                   y             z
   - 1 - 2 - 3 - 4 - 5 - 6 - 7 - 8 -    list out








---------------------------------------------------------------------------}
{----------------------------------------------------------------------------}

  -- fast flattening for trees

  flit : forall {l u z} ->

           Tree (l                , u) ->

           (forall {y}{{_ : LH (y , u)}} -> List (y , z)) ->

           List (l                                  , z)



  flit leaf           yz = yz           -- we've found somewhere left of u!

  flit (node lp p pu) yz = flit lp (p :: flit pu yz)
















{----------------------------------------------------------------------------}

  -- faster flattening in datatype generic style

  gflit :   forall {T l u z} ->
            MuOU T (l              , u) ->
            (forall {y}{{_ : LH (y , u)}} -> List (y , z)) ->
            List (l                                  , z)

  gflitH :  forall S {T l u z} ->
            OUF S (MuOU T) (l      , u) ->               -- olde diagonal trick
            (forall {y}{{_ : LH (y , u)}} -> List (y , z)) ->
            List (l                                  , z)

  gflit {T}       < t >       yz = gflitH T t yz

  gflitH `R       r           yz = gflit r yz
  gflitH `0       ()          yz
  gflitH `1       !           yz = yz
  gflitH (S `+ T) (inl s)     yz = gflitH S s yz
  gflitH (S `+ T) (inr t)     yz = gflitH T t yz
  gflitH (S `^ T) (s / p / t) yz = gflitH S s (p :: gflitH T t yz)


  -- Conor, you're running out of time, just skip this.



                                                              -- next TWICE, run it

{- end of module -}

module TryOrder where  -- mango

{----------------------------------------------------------------------------}

  LN : Rel Nat
  LN (ze   , _)    = One
  LN (su _ , ze)   = Zero
  LN (su x , su y) = LN (x , y)

  nowoto : forall x y -> OWOTO LN (x , y)
  nowoto ze     y      = le
  nowoto (su x) ze     = ge
  nowoto (su x) (su y) = nowoto x y

  open Order LN nowoto

{-(-}
  intv : Intv (val 3 , val 7)
  intv = [ 4 ]
{-)-}

  -- C-r banana











{----------------------------------------------------------------------------}

  -- At the risk of losing a well built reputation, I propose to RUN a program.

{-+}
  tree : Tree (bot , top)
  tree = node (node leaf 10 leaf) 20 (node leaf 30 leaf)

  more : Tree (bot , top)
  more = insert [ ? ] tree

  done : List (bot , top)
  done = gflit more nil
{+-}








  -- Conor, remember you're in a module and normalize TryOrder.done





                                                                   -- next, indexed









module IndexedOrder
  {P : Set}
  (L : Rel P)
  (owoto : (x y : P) -> OWOTO L (x , y))
  where

  data Bnd : Set where
    bot : Bnd
    val : P -> Bnd
    top : Bnd

  LH LB : Rel Bnd
  LH (bot    , _     ) = One
  LH (val x  , val y ) = L (x , y)
  LH (_      , top   ) = One
  LH         _         = Zero
  LB xy = Prf (LH xy)

  _^-_ : Rel Bnd -> Rel Bnd -> Rel Bnd
  (S ^- T) (l , u) = Sg _ \ p -> S (l , val p) * T (val p , u)
  pattern _/_/_ lp p pu = p , lp , pu


{-----------------------------------------------------------------------------}
  
  -- For extra invariants, index!

  data IOU (I : Set) : Set where        -- I is the set of indices
    `R         : I -> IOU I             -- we index each recursive position
    `0 `1      : IOU I
    _`+_ _`^_  : (S T : IOU I) -> IOU I

  IOUF : forall {I} -> IOU I
         -> (I -> Rel Bnd)      -- index things to put in recursive positions
         -> Rel Bnd
  IOUF (`R i)   R = R i
  IOUF `0       R = Zero-
  IOUF `1       R = LB
  IOUF (S `+ T) R = IOUF S R +- IOUF T R
  IOUF (S `^ T) R = IOUF S R ^- IOUF T R  -- s / p / t

  data MuIOU {I}
        (T : I -> IOU I)               -- *compute* the node description
        (i : I)(lu : Bnd * Bnd) : Set
    where
    <_> : IOUF (T i) (MuIOU T) lu -> MuIOU T i lu





                                                      -- next, recover the old stuff


{-----------------------------------------------------------------------------}

  -- Recover the simple stuff by taking I = One, i = <>

  Intv : Rel Bnd
  Intv = MuIOU (\ _ -> `1 `^ `1) <>
  pattern [_] p = < ! / p / ! >

  List = MuIOU (\ _ -> `1 `+ (`1 `^ `R <>)) <>
  pattern nil = < inl ! >
  pattern _::_ x xs = < inr (! / x / xs) >

















                                                                -- next, 2-3

{-----------------------------------------------------------------------------}

  -- Index by height to create balanced 2-3-trees

  T23 : Nat -> Rel Bnd
  T23 = MuIOU \                                        -- Conor, is there time
        { ze      -> `1                                -- to do the rant about
        ; (su n)  -> `R n `^ (`R n `+ (`R n `^ `R n))  -- being Reprah Trebor?
        }                                                -- Ask me in the bar.

  -- case analysis on the index tells us if we should have a leaf or a node
  --
  -- height    ze                            su n
  --
  --          l u            l  ..p..  u            l  ..p.. ..r..  u
  --                           :     :                :     :     :
  --                           ^     ^        or      ^     ^     ^
  --           -              /n\   /n\              /n\   /n\   /n\

  pattern leaf0               = < ! >
  pattern node2 lp p pu       = < lp / p / inl pu >
  pattern node3 lp p pr r ru  = < lp / p / inr (pr / r / ru) >






                                                                 -- next, insert

{-----------------------------------------------------------------------------}

  -- When you insert a new key into a 2-3-tree, you get something the same
  -- height, or only just taller.

  It's2Tall : Nat -> Rel Bnd         -- that's the stuff for a *2*-node
  It's2Tall n = T23 n ^- T23 n       -- of height (su n)

{-(-}
  ins23 : {n : Nat} -> [- Intv ->- T23 n ->- (T23 n +- It's2Tall n) -]
  ins23 {ze}   [ x ] leaf0             = inr (leaf0 / x / leaf0)
  ins23 {su n} [ x ] < lp / p / pu >   with owoto x p
  ins23 {su n} {fst , snd} < x , ! , ! > < p , lp , pu > | le with ins23 [ x ] lp
  ins23 {su n} {fst , snd} < x , ! , ! > < p , lp , pu > | inl ! | inl x₁ = inl < p , x₁ , pu >
  ins23 {su n} {fst , snd} < x , ! , ! > < p , lp , pu > | inl ! | inr x₁ = {!!}
  ins23 {su n} {fst , snd} < x , ! , ! > < p , lp , pu > | inr x₁ = {!!}
{-)-}















                                                                    -- next, conc






{-----------------------------------------------------------------------------

  Get off already, Conor.

  YOU TOO can spend FIFTEEN YEARS screwing up and refining one definition
  until it makes your program look THIS CLEAN.

  But I guess you'd rather not.

    Write types which PUSH REQUIREMENTS IN.
    Write programs which generate EVIDENCE.

  See how far you can get before you need to prove a theorem.















                                                               -- next, easy vs hard

-----------------------------------------------------------------------------}
{-----------------------------------------------------------------------------

  Get off already, Conor.

  YOU TOO can spend FIFTEEN YEARS screwing up and refining one definition
  until it makes your program look THIS CLEAN.

  But I guess you'd rather not.

    Write types which PUSH REQUIREMENTS IN.
    Write programs which generate EVIDENCE.

  See how far you can get before you need to prove a theorem.




   "Why do something easy?"

   vs

   "Why put up with difficult?"






-- "God's immaculate machine"

-----------------------------------------------------------------------------}
